from graphic_classes import GraphicWrapper
import pygame

WHITE = (255,255,255)

INVIS = (255,0,255)

class GraphicSimulator():
    def __init__(self,dt,junctions,roads,cars,draw_traj):
        #Initialise the pygame instance
        pygame.init()

        #The height and width of the screen pygame opens (in pixels)
        height = 640
        width = 1024

        #Define the unit value to ensure the graphic doesn't go off the screen
        #Unit defines the length of a metre in the simulation
        self.unit = setUnitVal(junctions,height,width)
        self.max_fps = 1/dt

        #Initialise the background and the screen that the graphics get written onto
        self.initialiseBackground(width,height)

        #Initialise the sprite groups for the junctions, the roads and the cars 
        self.junc_list = [GraphicWrapper(x,self.unit) for x in junctions]
        self.road_list = [GraphicWrapper(x,self.unit) for x in roads]
        self.car_list = [GraphicWrapper(x,self.unit) for x in cars]

        #This is true if pygame detects that x button is clicked.
        # If true then graphic will close but simulation will continue to run
        self.is_quit = False

        self.draw_traj = draw_traj

        #The clock controlling the runs of the simulation to ensure they run smooth
        self.clock = pygame.time.Clock()


    def initialiseBackground(self,width,height):
        """Sets up the background and the screen that the simulator will be drawn on.
           Width and height are the dimensions of the the screen generated by pygame
           (in pixels)"""
        self.screen = pygame.display.set_mode([width,height])
        self.background = pygame.Surface(self.screen.get_size())
        #White is a generic background colour
        self.background.set_colorkey(INVIS)
        self.screen.set_colorkey(INVIS)
        self.background.fill(WHITE)


    def update(self):
        """Updates the perspective of the screen to match the current formulation of
           the symbolic simulation"""
        #If we don't check to make sure pygame has not already quit then we get an error
        # when we try to update the sprite values
        if not self.is_quit:
            #Determine the new value for is_quit if it is currently False
            self.checkForQuit()

        #Same reason as above. A call to "checkForQuit" above might have 
        # changed is_quit to True, thus resulting in an error if this is run
        if not self.is_quit:
            self.screen.blit(self.background,(0,0)) #Clears the screen, redraws background
            for lizt in [self.junc_list,self.road_list,self.car_list]:
                self.drawToScreen(lizt)

            if self.draw_traj:
                for car in self.car_list:
                    traj_coords = [[car.obj.x_com,car.obj.y_com]] + \
                            car.obj.waypoints[car.obj.traj_posit:]
                    drawTrajectory(traj_coords,self.unit,self.screen)

            self.clock.tick(self.max_fps)
            pygame.display.flip()


    def drawToScreen(self,obj_list):
        """Draws the sprites stored in the sprite group "obj_list" onto the screen"""
        for obj in obj_list:
            obj.draw(self.screen,self.unit)


    def shutdown(self):
        """Store the final image from the simulation and then shut down the pygame instance"""
        pygame.image.save(self.screen,"screenshot.jpeg")
        pygame.quit()
        self.is_quit = True


    def checkForQuit(self):
        """Checks to see if someone has clicked the close button, setting the value of
           "is_quit" accordingly"""
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                self.is_quit = True


    def drawScene(self):
        """Used for inspecting static moments without progressing in the simulation.
           Repeatedly draws the current state of the simulation until a keyboard key is pressed"""
        acts = [x.type for x in pygame.event.get()]
        while pygame.KEYDOWN not in acts and pygame.QUIT not in acts:
            self.update()
            acts = [x.type for x in pygame.event.get()]


def drawTrajectory(coords,unit,screen):
    coords = [[unit*x[0],unit*x[1]] for x in coords]
    pygame.draw.lines(screen,(0,255,0),False,coords)


def setUnitVal(junctions,height,width):
    """Set the scaling constant for the simulator so that the graphics don't
       go off the screen"""
    max_height = -1
    max_width = -1
    for entry in junctions:
        max_x = max([entry.four_corners[x][0] for x in entry.four_corners])
        max_y = max([entry.four_corners[x][1] for x in entry.four_corners])
        if max_x>max_width: max_width = max_x
        if max_y>max_height: max_height = max_y

    #Get the largest value in either direction, divide the total available
    # distance by it. This gives you the scaling constant
    return min(height*1.0/max_height,width*1.0/max_width)
