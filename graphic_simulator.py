from graphic_classes import GraphicWrapper
import pygame

from  datetime import datetime as dt
import os #To position screen
import time
import pyautogui #To size the screen

WHITE = (255,255,255)
GREEN = (0,255,0)

INVIS = (255,0,255)

class GraphicSimulator():
    def __init__(self,dt,junctions,roads,cars,draw_traj,window_position=None,window_dimensions=None):
        #Initialise the pygame instance
        pygame.init()

        #The height and width of the screen pygame opens (in pixels)
        screen_w,screen_h = pyautogui.size()
        if window_dimensions == None:
            w,h = screen_w,screen_h
        else:
            w,h = window_dimensions
        height = h-20
        width = w-20
        
        #Position of the window in the screen when pygame opens
        if window_position is None:
            window_position = [(screen_w-width)/2,(screen_h-height)/2]
        #Setting the position of the top right of the window when it is intitialised
        os.environ['SDL_VIDEO_WINDOW_POS'] = "{},{}".format(window_position[0],window_position[1])

        #Position of the window in the screen when pygame opens
        if window_position is None:
            window_position = [(screen_w-width)/2,(screen_h-height)/2]
        #Setting the position of the top right of the window when it is intitialised
        os.environ['SDL_VIDEO_WINDOW_POS'] = "{},{}".format(window_position[0],window_position[1])

        #Define the unit value to ensure the graphic doesn't go off the screen
        #Unit defines the length of a metre in the simulation
        self.unit = setUnitVal(junctions,height,width)
        self.max_fps = 1/dt

        #Initialise the background and the screen that the graphics get written onto
        self.initialiseBackground(width,height)

        #Initialise the sprite groups for the junctions, the roads and the cars 
        self.junc_list = [GraphicWrapper(x,self.unit) for x in junctions]
        self.road_list = [GraphicWrapper(x,self.unit) for x in roads]
        self.car_list = [GraphicWrapper(x,self.unit) for x in cars]

        #This is true if pygame detects that x button is clicked.
        # If true then graphic will close but simulation will continue to run
        self.is_quit = False

        self.draw_traj = draw_traj

        #The clock controlling the runs of the simulation to ensure they run smooth
        self.clock = pygame.time.Clock()

        #Triggers; keys of dictionary is a binary function. At the end of each round of simulation (in endStep)
        # If the key returns true then the corresponding function is executed.
        self.triggers = {}


    def initialiseBackground(self,width,height):
        """Sets up the background and the screen that the simulator will be drawn on.
           Width and height are the dimensions of the the screen generated by pygame
           (in pixels)"""
        self.screen = pygame.display.set_mode([width,height])
        self.background = pygame.Surface(self.screen.get_size())
        #White is a generic background colour
        self.background.set_colorkey(INVIS)
        self.screen.set_colorkey(INVIS)
        #self.background.fill(WHITE)
        self.background.fill(GREEN)


    def update(self):
        """Updates the perspective of the screen to match the current formulation of
           the symbolic simulation"""
        #If we don't check to make sure pygame has not already quit then we get an error
        # when we try to update the sprite values
        if not self.is_quit:
            #Determine the new value for is_quit if it is currently False
            self.checkForQuit()

        #Same reason as above. A call to "checkForQuit" above might have 
        # changed is_quit to True, thus resulting in an error if this is run
        if not self.is_quit:
            self.screen.blit(self.background,(0,0)) #Clears the screen, redraws background
            for lizt in [self.junc_list,self.road_list,self.car_list]:
                self.drawToScreen(lizt)

            if self.draw_traj:
                for car in self.car_list:
                    traj_coords = [[car.obj.x_com,car.obj.y_com]] + \
                            car.obj.waypoints[car.obj.traj_posit:]
                    drawTrajectory(traj_coords,self.unit,self.screen)

            self.clock.tick(self.max_fps)


    def drawToScreen(self,obj_list):
        """Draws the sprites stored in the sprite group "obj_list" onto the screen"""
        for obj in obj_list:
            obj.draw(self.screen,self.unit)


    def shutdown(self):
        """Shut down the pygame instance"""
        pygame.quit()
        self.is_quit = True


    def checkForQuit(self):
        """Checks to see if someone has clicked the close button, setting the value of
           "is_quit" accordingly"""
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                self.is_quit = True

    def drawScene(self):
        """Used to get initial state of simulation"""
        #This is easier than trying to pause it at just the right moment
        print("Simulation is Paused")
        while not pygame.key.get_pressed()[pygame.K_SPACE]:
            self.update()
            self.checkForSnapshot()
        print("Resuming Simulation")


    def checkForPause(self):
        is_pressed = pygame.key.get_pressed()[pygame.K_SPACE]
        if is_pressed:
            self.pauseSimulation()


    def pauseSimulation(self):
        print("Simulation is Paused")
        is_pressed = False
        pygame.time.wait(1000)
        while not is_pressed:
            self.update()
            self.checkForSnapshot()
            is_pressed = pygame.key.get_pressed()[pygame.K_SPACE]

        print("Resuming Simulation")


    def checkForSnapshot(self):
        if pygame.key.get_pressed()[pygame.K_RETURN]:
            now = dt.now()
            snapshot_name = "screenshot-{}.jpeg".format(now.strftime("%d-%m-%y_%H-%M-%S"))
            pygame.image.save(self.screen,snapshot_name)
            print("GS: Snapshot {} of simulator has been taken".format(snapshot_name))


    def addTriggers(self,trigger_dict):
        self.triggers.update(trigger_dict)


    def endStep(self):
        #Trigger key is binary function dependent on the state.
        #If the triggr is true, the consequent is executed
        for trigger in self.triggers.keys():
            if trigger(): self.triggers[trigger]()

        self.checkForPause()
        self.checkForSnapshot()

        pygame.display.flip() #flip screen after all changes made


def drawTrajectory(coords,unit,screen):
    coords = [[unit*x[0],unit*x[1]] for x in coords]
    pygame.draw.lines(screen,(0,255,0),False,coords)


def setUnitVal(junctions,height,width):
    """Set the scaling constant for the simulator so that the graphics don't
       go off the screen"""
    max_height = -1
    max_width = -1
    for entry in junctions:
        max_x = max([entry.four_corners[x][0] for x in entry.four_corners])
        max_y = max([entry.four_corners[x][1] for x in entry.four_corners])
        if max_x>max_width: max_width = max_x
        if max_y>max_height: max_height = max_y

    #Get the largest value in either direction, divide the total available
    # distance by it. This gives you the scaling constant
    return min(height*1.0/max_height,width*1.0/max_width)
