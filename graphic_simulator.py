import graphic_classes
import pygame

WHITE = (255,255,255)


class GraphicSimulator():
    def __init__(self,junctions,roads,cars):
        #Initialise the pygame instance
        pygame.init()
        
        #The height and width of the screen pygame opens (in pixels)
        height = 640
        width = 1024

        #Define the unit value to ensure the graphic doesn't go off the screen
        self.unit = setUnitVal(junctions,height,width)
       
        #Initialise the sprite groups for the junctions, the roads and the cars 
        self.junc_list = makeSpriteGroup(junctions,width,height,self.unit)
        self.road_list = makeSpriteGroup(roads,width,height,self.unit)
        self.car_list = makeSpriteGroup(cars,width,height,self.unit)

        #This is true if pygame detects that x button is clicked.
        # If true then graphic will close but simulation will continue to run
        self.is_quit = False 

        #Initialise the background and the screen that the graphics get written onto
        self.initialiseBackground(width,height)

        #The clock controlling the runs of the simulation to ensure they run smooth
        self.clock = pygame.time.Clock()


    def initialiseBackground(self,width,height):
        """Sets up the background and the screen that the simulator will be drawn on.
           Width and height are the dimensions of the the screen generated by pygame 
           (in pixels)"""
        self.screen = pygame.display.set_mode([width,height])
        self.background = pygame.Surface(self.screen.get_size())
        #White is a generic background colour
        self.background.fill(WHITE)


    def setUnitVal(junctions,height,width):
        """Set the scaling constant for the simulator so that the graphics don't 
           go off the screen"""
        max_height = -1
        max_width = -1
        for entry in junctions:
            max_x = max([entry.four_corners[x][0] for x in entry.four_corners])
            max_y = max([entry.four_corners[x][1] for x in entry.four_corners])
            if max_x>max_width: max_width = max_x
            if max_y>max_height: max_height = max_y

        #Get the largest value in either direction, divide the total available
        # distance by it. This gives you the scaling constant
        return min(height*1.0/max_height,width*1.0/max_width)


    def update(self):
        """Updates the perspective of the screen to match the current formulation of 
           the symbolic simulation"""
        #If we don't check to make sure pygame has not already quit then we get an error
        # when we try to update the sprite values
        if not self.is_quit:
            for lizt in [self.junc_list,self.road_list,self.car_list]:
                lizt = updateList(lizt,self.unit)

            #Determine the new value for is_quit if it is currently False
            self.checkForQuit()

        #Same reason as above. A call to "checkForQuit" above might have 
        # changed is_quit to True, thus resulting in an error if this is run
        if not self.is_quit:
            self.screen.blit(self.background,(0,0))
            pygame.display.update()
            for lizt in [self.junc_list,self.road_list,self.car_list]:
                self.drawToScreen(lizt)

            self.clock.tick(10)
            pygame.display.flip()


    def drawToScreen(self,obj_list):
        """Draws the sprites stored in the sprite group "obj_list" onto the screen"""
        obj_list.draw(self.screen)


    def checkForQuit(self):
        """Checks to see if someone has clicked the close button, setting the value of
           "is_quit" accordingly"""
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                self.is_quit = True


def updateList(obj_list,unit):
    """Updates the positions of the objects in the list, using the scaling unit
       to adjust the proportions accordingly"""
    for entry in obj_list:
        entry.draw(unit)


def makeSpriteGroup(obj_list,width,height,unit):
    """Given a list of objects constructs a graphical sprite (GraphicWrapper from
       graphic_classes) for each object and puts the entire contents of the list
       into a sprite group. Each item is drawn and then the sprite group is returned"""
    objs = [graphic_classes.GraphicWrapper(x,width,height) for x in obj_list]
    g_obj_list = pygame.sprite.Group()
    for entry in objs:
        entry.draw(unit)
        g_obj_list.add(entry)
    return g_obj_list


def setUnitVal(junctions,height,width):
    """Set the scaling constant for the simulator so that the graphics don't 
       go off the screen"""
    max_height = -1
    max_width = -1
    for entry in junctions:
        max_x = max([entry.four_corners[x][0] for x in entry.four_corners])
        max_y = max([entry.four_corners[x][1] for x in entry.four_corners])
        if max_x>max_width: max_width = max_x
        if max_y>max_height: max_height = max_y

    #Get the largest value in either direction, divide the total available
    # distance by it. This gives you the scaling constant
    return min(height*1.0/max_height,width*1.0/max_width)
